{"ast":null,"code":"var _jsxFileName = \"/Users/ralf/PyPrograms/KanbanFlow-Web/kanban-gui-test/src/components/FlyingCardAnimation.js\",\n  _s = $RefreshSig$();\n// kanban-gui-test/src/components/FlyingCardAnimation.js\n\nimport React, { useEffect, useRef, useState } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst FlyingCardAnimation = ({\n  card,\n  startRect,\n  endRect,\n  onAnimationEnd\n}) => {\n  _s();\n  const animatedRef = useRef(null);\n  const animationInstanceRef = useRef(null);\n  useEffect(() => {\n    if (!animatedRef.current || !startRect || !endRect) {\n      // console.log(`[FlyingCardAnimation] Card ${card.id}: Waiting for all props (ref=${!!animatedRef.current}, start=${!!startRect}, end=${!!endRect}) to start animation.`);\n      return; // Wait for all props and ref to be ready\n    }\n\n    // Ensure animation is only started once for this component instance\n    if (animationInstanceRef.current) {\n      // console.log(`[FlyingCardAnimation] Card ${card.id}: Animation already started for this instance.`);\n      return;\n    }\n    console.log(`[FlyingCardAnimation] Card ${card.id}: Starting animation from (${startRect.left},${startRect.top}) to (${endRect.left},${endRect.top})`);\n    const deltaX = endRect.left - startRect.left;\n    const deltaY = endRect.top - startRect.top;\n    const keyframes = [{\n      transform: 'translate(0, 0)',\n      opacity: 1\n    }, {\n      transform: `translate(${deltaX}px, ${deltaY}px)`,\n      opacity: 1\n    }];\n    const options = {\n      duration: 500,\n      // Animation duration in milliseconds\n      easing: 'ease-in-out',\n      fill: 'forwards'\n    };\n    animationInstanceRef.current = animatedRef.current.animate(keyframes, options);\n    animationInstanceRef.current.finished.then(() => {\n      console.log(`[FlyingCardAnimation] Promise-based animation finished for card: ${card.id}`);\n      onAnimationEnd(card.id);\n    }).catch(error => {\n      if (error.name === 'AbortError') {\n        console.log(`[FlyingCardAnimation] Card ${card.id}: Animation was cancelled.`);\n      } else {\n        console.error(`[FlyingCardAnimation] Card ${card.id}: Animation error:`, error);\n      }\n    });\n\n    // Fallback: If for some reason onfinish promise doesn't resolve,\n    // ensure the animation entry is cleared after a set time.\n    const fallbackTimeout = setTimeout(() => {\n      // Check if the animation is not in 'finished' or 'idle' state.\n      // 'idle' means it hasn't started or has been cancelled before starting.\n      // 'finished' means it completed.\n      // If it's in 'running', 'paused', or 'pending' state after duration+grace, something's wrong.\n      if (animationInstanceRef.current && animationInstanceRef.current.playState !== 'finished' && animationInstanceRef.current.playState !== 'idle') {\n        console.warn(`[FlyingCardAnimation] Fallback: Animation for card ${card.id} did not finish (playState: ${animationInstanceRef.current.playState}). Forcing cleanup.`);\n        onAnimationEnd(card.id);\n        animationInstanceRef.current.cancel(); // Cancel to clean up DOM elements potentially held by animation\n      }\n    }, options.duration + 200); // 200ms grace period after expected duration\n\n    return () => {\n      if (animationInstanceRef.current) {\n        animationInstanceRef.current.cancel(); // Clean up animation on unmount\n      }\n      clearTimeout(fallbackTimeout); // Clear fallback if component unmounts early or animation finishes properly\n    };\n  }, [card.id, startRect, endRect, onAnimationEnd]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: animatedRef,\n    className: \"bg-white p-4 mb-3 rounded shadow-md pointer-events-none\",\n    style: {\n      position: 'fixed',\n      left: startRect ? startRect.left : 0,\n      top: startRect ? startRect.top : 0,\n      width: startRect ? startRect.width : 0,\n      height: startRect ? startRect.height : 0,\n      zIndex: 1000,\n      opacity: startRect ? 1 : 0\n    },\n    children: card.birth_id ? `Karte ${card.birth_id}` : card.id\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 73,\n    columnNumber: 5\n  }, this);\n};\n_s(FlyingCardAnimation, \"w/TLPhCrXeBNU/fiGHfy6XXZLuo=\");\n_c = FlyingCardAnimation;\nexport default FlyingCardAnimation;\nvar _c;\n$RefreshReg$(_c, \"FlyingCardAnimation\");","map":{"version":3,"names":["React","useEffect","useRef","useState","jsxDEV","_jsxDEV","FlyingCardAnimation","card","startRect","endRect","onAnimationEnd","_s","animatedRef","animationInstanceRef","current","console","log","id","left","top","deltaX","deltaY","keyframes","transform","opacity","options","duration","easing","fill","animate","finished","then","catch","error","name","fallbackTimeout","setTimeout","playState","warn","cancel","clearTimeout","ref","className","style","position","width","height","zIndex","children","birth_id","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/ralf/PyPrograms/KanbanFlow-Web/kanban-gui-test/src/components/FlyingCardAnimation.js"],"sourcesContent":["// kanban-gui-test/src/components/FlyingCardAnimation.js\n\nimport React, { useEffect, useRef, useState } from 'react';\n\nconst FlyingCardAnimation = ({ card, startRect, endRect, onAnimationEnd }) => {\n  const animatedRef = useRef(null);\n  const animationInstanceRef = useRef(null);\n\n  useEffect(() => {\n    if (!animatedRef.current || !startRect || !endRect) {\n        // console.log(`[FlyingCardAnimation] Card ${card.id}: Waiting for all props (ref=${!!animatedRef.current}, start=${!!startRect}, end=${!!endRect}) to start animation.`);\n        return; // Wait for all props and ref to be ready\n    }\n\n    // Ensure animation is only started once for this component instance\n    if (animationInstanceRef.current) {\n        // console.log(`[FlyingCardAnimation] Card ${card.id}: Animation already started for this instance.`);\n        return;\n    }\n\n    console.log(`[FlyingCardAnimation] Card ${card.id}: Starting animation from (${startRect.left},${startRect.top}) to (${endRect.left},${endRect.top})`);\n\n    const deltaX = endRect.left - startRect.left;\n    const deltaY = endRect.top - startRect.top;\n\n    const keyframes = [\n      { transform: 'translate(0, 0)', opacity: 1 },\n      { transform: `translate(${deltaX}px, ${deltaY}px)`, opacity: 1 },\n    ];\n\n    const options = {\n      duration: 500, // Animation duration in milliseconds\n      easing: 'ease-in-out',\n      fill: 'forwards',\n    };\n\n    animationInstanceRef.current = animatedRef.current.animate(keyframes, options);\n\n    animationInstanceRef.current.finished.then(() => {\n      console.log(`[FlyingCardAnimation] Promise-based animation finished for card: ${card.id}`);\n      onAnimationEnd(card.id);\n    }).catch(error => {\n      if (error.name === 'AbortError') {\n        console.log(`[FlyingCardAnimation] Card ${card.id}: Animation was cancelled.`);\n      } else {\n        console.error(`[FlyingCardAnimation] Card ${card.id}: Animation error:`, error);\n      }\n    });\n\n    // Fallback: If for some reason onfinish promise doesn't resolve,\n    // ensure the animation entry is cleared after a set time.\n    const fallbackTimeout = setTimeout(() => {\n        // Check if the animation is not in 'finished' or 'idle' state.\n        // 'idle' means it hasn't started or has been cancelled before starting.\n        // 'finished' means it completed.\n        // If it's in 'running', 'paused', or 'pending' state after duration+grace, something's wrong.\n        if (animationInstanceRef.current && animationInstanceRef.current.playState !== 'finished' && animationInstanceRef.current.playState !== 'idle') {\n            console.warn(`[FlyingCardAnimation] Fallback: Animation for card ${card.id} did not finish (playState: ${animationInstanceRef.current.playState}). Forcing cleanup.`);\n            onAnimationEnd(card.id);\n            animationInstanceRef.current.cancel(); // Cancel to clean up DOM elements potentially held by animation\n        }\n    }, options.duration + 200); // 200ms grace period after expected duration\n\n    return () => {\n      if (animationInstanceRef.current) {\n        animationInstanceRef.current.cancel(); // Clean up animation on unmount\n      }\n      clearTimeout(fallbackTimeout); // Clear fallback if component unmounts early or animation finishes properly\n    };\n  }, [card.id, startRect, endRect, onAnimationEnd]);\n\n  return (\n    <div\n      ref={animatedRef}\n      className=\"bg-white p-4 mb-3 rounded shadow-md pointer-events-none\"\n      style={{\n        position: 'fixed',\n        left: startRect ? startRect.left : 0,\n        top: startRect ? startRect.top : 0,\n        width: startRect ? startRect.width : 0,\n        height: startRect ? startRect.height : 0,\n        zIndex: 1000,\n        opacity: startRect ? 1 : 0,\n      }}\n    >\n      {card.birth_id ? `Karte ${card.birth_id}` : card.id}\n    </div>\n  );\n};\n\nexport default FlyingCardAnimation;"],"mappings":";;AAAA;;AAEA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAE3D,MAAMC,mBAAmB,GAAGA,CAAC;EAAEC,IAAI;EAAEC,SAAS;EAAEC,OAAO;EAAEC;AAAe,CAAC,KAAK;EAAAC,EAAA;EAC5E,MAAMC,WAAW,GAAGV,MAAM,CAAC,IAAI,CAAC;EAChC,MAAMW,oBAAoB,GAAGX,MAAM,CAAC,IAAI,CAAC;EAEzCD,SAAS,CAAC,MAAM;IACd,IAAI,CAACW,WAAW,CAACE,OAAO,IAAI,CAACN,SAAS,IAAI,CAACC,OAAO,EAAE;MAChD;MACA,OAAO,CAAC;IACZ;;IAEA;IACA,IAAII,oBAAoB,CAACC,OAAO,EAAE;MAC9B;MACA;IACJ;IAEAC,OAAO,CAACC,GAAG,CAAC,8BAA8BT,IAAI,CAACU,EAAE,8BAA8BT,SAAS,CAACU,IAAI,IAAIV,SAAS,CAACW,GAAG,SAASV,OAAO,CAACS,IAAI,IAAIT,OAAO,CAACU,GAAG,GAAG,CAAC;IAEtJ,MAAMC,MAAM,GAAGX,OAAO,CAACS,IAAI,GAAGV,SAAS,CAACU,IAAI;IAC5C,MAAMG,MAAM,GAAGZ,OAAO,CAACU,GAAG,GAAGX,SAAS,CAACW,GAAG;IAE1C,MAAMG,SAAS,GAAG,CAChB;MAAEC,SAAS,EAAE,iBAAiB;MAAEC,OAAO,EAAE;IAAE,CAAC,EAC5C;MAAED,SAAS,EAAE,aAAaH,MAAM,OAAOC,MAAM,KAAK;MAAEG,OAAO,EAAE;IAAE,CAAC,CACjE;IAED,MAAMC,OAAO,GAAG;MACdC,QAAQ,EAAE,GAAG;MAAE;MACfC,MAAM,EAAE,aAAa;MACrBC,IAAI,EAAE;IACR,CAAC;IAEDf,oBAAoB,CAACC,OAAO,GAAGF,WAAW,CAACE,OAAO,CAACe,OAAO,CAACP,SAAS,EAAEG,OAAO,CAAC;IAE9EZ,oBAAoB,CAACC,OAAO,CAACgB,QAAQ,CAACC,IAAI,CAAC,MAAM;MAC/ChB,OAAO,CAACC,GAAG,CAAC,oEAAoET,IAAI,CAACU,EAAE,EAAE,CAAC;MAC1FP,cAAc,CAACH,IAAI,CAACU,EAAE,CAAC;IACzB,CAAC,CAAC,CAACe,KAAK,CAACC,KAAK,IAAI;MAChB,IAAIA,KAAK,CAACC,IAAI,KAAK,YAAY,EAAE;QAC/BnB,OAAO,CAACC,GAAG,CAAC,8BAA8BT,IAAI,CAACU,EAAE,4BAA4B,CAAC;MAChF,CAAC,MAAM;QACLF,OAAO,CAACkB,KAAK,CAAC,8BAA8B1B,IAAI,CAACU,EAAE,oBAAoB,EAAEgB,KAAK,CAAC;MACjF;IACF,CAAC,CAAC;;IAEF;IACA;IACA,MAAME,eAAe,GAAGC,UAAU,CAAC,MAAM;MACrC;MACA;MACA;MACA;MACA,IAAIvB,oBAAoB,CAACC,OAAO,IAAID,oBAAoB,CAACC,OAAO,CAACuB,SAAS,KAAK,UAAU,IAAIxB,oBAAoB,CAACC,OAAO,CAACuB,SAAS,KAAK,MAAM,EAAE;QAC5ItB,OAAO,CAACuB,IAAI,CAAC,sDAAsD/B,IAAI,CAACU,EAAE,+BAA+BJ,oBAAoB,CAACC,OAAO,CAACuB,SAAS,qBAAqB,CAAC;QACrK3B,cAAc,CAACH,IAAI,CAACU,EAAE,CAAC;QACvBJ,oBAAoB,CAACC,OAAO,CAACyB,MAAM,CAAC,CAAC,CAAC,CAAC;MAC3C;IACJ,CAAC,EAAEd,OAAO,CAACC,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC;;IAE5B,OAAO,MAAM;MACX,IAAIb,oBAAoB,CAACC,OAAO,EAAE;QAChCD,oBAAoB,CAACC,OAAO,CAACyB,MAAM,CAAC,CAAC,CAAC,CAAC;MACzC;MACAC,YAAY,CAACL,eAAe,CAAC,CAAC,CAAC;IACjC,CAAC;EACH,CAAC,EAAE,CAAC5B,IAAI,CAACU,EAAE,EAAET,SAAS,EAAEC,OAAO,EAAEC,cAAc,CAAC,CAAC;EAEjD,oBACEL,OAAA;IACEoC,GAAG,EAAE7B,WAAY;IACjB8B,SAAS,EAAC,yDAAyD;IACnEC,KAAK,EAAE;MACLC,QAAQ,EAAE,OAAO;MACjB1B,IAAI,EAAEV,SAAS,GAAGA,SAAS,CAACU,IAAI,GAAG,CAAC;MACpCC,GAAG,EAAEX,SAAS,GAAGA,SAAS,CAACW,GAAG,GAAG,CAAC;MAClC0B,KAAK,EAAErC,SAAS,GAAGA,SAAS,CAACqC,KAAK,GAAG,CAAC;MACtCC,MAAM,EAAEtC,SAAS,GAAGA,SAAS,CAACsC,MAAM,GAAG,CAAC;MACxCC,MAAM,EAAE,IAAI;MACZvB,OAAO,EAAEhB,SAAS,GAAG,CAAC,GAAG;IAC3B,CAAE;IAAAwC,QAAA,EAEDzC,IAAI,CAAC0C,QAAQ,GAAG,SAAS1C,IAAI,CAAC0C,QAAQ,EAAE,GAAG1C,IAAI,CAACU;EAAE;IAAAiC,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAChD,CAAC;AAEV,CAAC;AAAC1C,EAAA,CApFIL,mBAAmB;AAAAgD,EAAA,GAAnBhD,mBAAmB;AAsFzB,eAAeA,mBAAmB;AAAC,IAAAgD,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}