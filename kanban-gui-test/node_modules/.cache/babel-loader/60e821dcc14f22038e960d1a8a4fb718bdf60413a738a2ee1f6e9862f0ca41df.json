{"ast":null,"code":"var _jsxFileName = \"/Users/ralf/PyPrograms/KanbanFlow-Web/kanban-gui-test/src/components/Board.js\",\n  _s = $RefreshSig$();\n// src/components/Board.js\nimport React, { useState, useCallback, useRef, useEffect } from 'react'; // <--- Import useRef and useEffect\nimport Lane from './Lane';\nimport Card from './Card'; // Import Card to use its structure for flying clones\nimport FlyingCardAnimation from './FlyingCardAnimation'; // <--- Import new component\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Board = () => {\n  _s();\n  const [lanes, setLanes] = useState([{\n    id: 'lane-1',\n    title: 'To Do',\n    cards: [{\n      id: 'card-1',\n      text: 'Define project scope'\n    }, {\n      id: 'card-2',\n      text: 'Research market trends'\n    }]\n  }, {\n    id: 'lane-2',\n    title: 'In Progress',\n    cards: [{\n      id: 'card-3',\n      text: 'Develop initial prototype'\n    }]\n  }, {\n    id: 'lane-3',\n    title: 'Done',\n    cards: [{\n      id: 'card-4',\n      text: 'Brainstorming session'\n    }]\n  }]);\n\n  // NEW: State to manage cards currently in flying animation\n  const [flyingAnimations, setFlyingAnimations] = useState([]);\n\n  // NEW: Store refs for each card element for position calculation\n  // We use useRef for a mutable object that persists across renders\n  // and a Map inside it to store refs dynamically for each card ID.\n  const cardRefs = useRef(new Map());\n  const laneRefs = useRef(new Map()); // Also need lane refs for target position\n\n  // This effect updates the cardRefs Map when cards or lanes change\n  useEffect(() => {\n    // Clean up old refs\n    cardRefs.current.clear();\n    laneRefs.current.clear();\n  }, [lanes]); // Re-run if lanes state structure changes, ensuring refs are fresh\n\n  // Helper to get a card by its ID from current lanes state\n  const getCardById = useCallback(cardId => {\n    for (const lane of lanes) {\n      const card = lane.cards.find(c => c.id === cardId);\n      if (card) return card;\n    }\n    return null;\n  }, [lanes]);\n\n  // Existing: Function to handle card moves via drag-and-drop\n  const moveCard = useCallback((cardId, currentLaneId, targetLaneId) => {\n    setLanes(prevLanes => {\n      const newLanes = prevLanes.map(lane => ({\n        ...lane,\n        cards: [...lane.cards]\n      }));\n      let movedCard = null;\n      const sourceLaneIndex = newLanes.findIndex(lane => lane.id === currentLaneId);\n      if (sourceLaneIndex > -1) {\n        const cardIndex = newLanes[sourceLaneIndex].cards.findIndex(card => card.id === cardId);\n        if (cardIndex > -1) {\n          movedCard = newLanes[sourceLaneIndex].cards.splice(cardIndex, 1)[0];\n        }\n      }\n      if (movedCard) {\n        const targetLaneIndex = newLanes.findIndex(lane => lane.id === targetLaneId);\n        if (targetLaneIndex > -1) {\n          newLanes[targetLaneIndex].cards.push(movedCard);\n        }\n      }\n      return newLanes;\n    });\n  }, []);\n\n  // NEW: Programmatic move function with gliding animation\n  const programmaticMoveCard = useCallback((cardId, targetLaneId) => {\n    const cardElement = cardRefs.current.get(cardId);\n    const targetLaneElement = laneRefs.current.get(targetLaneId);\n    if (!cardElement || !targetLaneElement) {\n      console.warn(`Could not find element for card ${cardId} or lane ${targetLaneId}`);\n      return;\n    }\n    const startRect = cardElement.getBoundingClientRect();\n    const currentCardData = getCardById(cardId);\n\n    // Prepare to initiate the animation *before* moving the actual card in state\n    setFlyingAnimations(prev => [...prev, {\n      id: `flying-${cardId}-${Date.now()}`,\n      // Unique ID for the animation instance\n      card: currentCardData,\n      startRect: startRect\n      // The endRect will be calculated after the actual card moves in the DOM\n    }]);\n\n    // Perform the actual card move in state\n    setLanes(prevLanes => {\n      const newLanes = prevLanes.map(lane => ({\n        ...lane,\n        cards: [...lane.cards]\n      }));\n      let movedCard = null;\n      const sourceLaneIndex = newLanes.findIndex(lane => {\n        const cardIndex = lane.cards.findIndex(card => card.id === cardId);\n        if (cardIndex > -1) {\n          movedCard = lane.cards.splice(cardIndex, 1)[0];\n          return true;\n        }\n        return false;\n      });\n      if (movedCard) {\n        const targetLaneIndex = newLanes.findIndex(lane => lane.id === targetLaneId);\n        if (targetLaneIndex > -1) {\n          newLanes[targetLaneIndex].cards.push(movedCard);\n        }\n      }\n      return newLanes;\n    });\n\n    // Use a short timeout to allow React to render the card in its new position\n    // then calculate its endRect and trigger the animation.\n    requestAnimationFrame(() => {\n      // Using rAF for next paint, often better than setTimeout(0)\n      const endCardElement = cardRefs.current.get(cardId);\n      if (endCardElement) {\n        const endRect = endCardElement.getBoundingClientRect();\n        // Update the flying animation entry with its endRect\n        setFlyingAnimations(prev => prev.map(anim => anim.card.id === cardId && !anim.endRect ? {\n          ...anim,\n          endRect: endRect\n        } : anim));\n      } else {\n        // If the card is no longer in DOM (e.g. removed for some reason), clean up flying animation\n        setFlyingAnimations(prev => prev.filter(anim => anim.card.id !== cardId));\n      }\n    });\n  }, [getCardById]);\n\n  // NEW: Callback for when a flying animation ends\n  const handleAnimationEnd = useCallback(cardId => {\n    setFlyingAnimations(prev => prev.filter(anim => anim.card.id !== cardId));\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"flex p-8 overflow-x-auto min-h-screen items-start bg-gray-50\",\n    children: [/*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => programmaticMoveCard('card-1', 'lane-2') // Moves 'card-1' to 'lane-2'\n      ,\n      className: \"fixed bottom-4 right-4 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded shadow-lg z-50\",\n      children: \"Auto Move Card 1 to 'In Progress' (Gliding)\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 157,\n      columnNumber: 7\n    }, this), lanes.map(lane => /*#__PURE__*/_jsxDEV(\"div\", {\n      ref: el => {\n        if (el) laneRefs.current.set(lane.id, el);\n      } // Assign ref to lane\n      ,\n      className: \"w-80 p-4 rounded-lg shadow-inner flex-shrink-0 mr-4 bg-gray-100\" // Note: removed isOver color for simplicity\n      ,\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        className: \"text-xl font-semibold mb-4 text-gray-800 border-b border-gray-300 pb-2\",\n        children: lane.title\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 170,\n        columnNumber: 11\n      }, this), lane.cards.map((card, index) => {\n        // Check if this card is currently being animated as a flying clone\n        const isFlyingClone = flyingAnimations.some(anim => anim.card.id === card.id && anim.endRect);\n        return /*#__PURE__*/_jsxDEV(Card, {\n          id: card.id,\n          text: card.text,\n          laneId: lane.id,\n          index: index\n          // Pass ref to the actual card so we can get its position\n          ,\n          ref: el => {\n            if (el) cardRefs.current.set(card.id, el);\n          }\n          // Hide the actual card while its clone is flying\n          ,\n          style: {\n            visibility: isFlyingClone ? 'hidden' : 'visible'\n          }\n        }, card.id, false, {\n          fileName: _jsxFileName,\n          lineNumber: 175,\n          columnNumber: 15\n        }, this);\n      })]\n    }, lane.id, true, {\n      fileName: _jsxFileName,\n      lineNumber: 165,\n      columnNumber: 9\n    }, this)), flyingAnimations.map(anim => anim.startRect && anim.endRect && /*#__PURE__*/_jsxDEV(FlyingCardAnimation, {\n      card: anim.card,\n      startRect: anim.startRect,\n      endRect: anim.endRect,\n      onAnimationEnd: handleAnimationEnd\n    }, anim.id, false, {\n      fileName: _jsxFileName,\n      lineNumber: 193,\n      columnNumber: 9\n    }, this))]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 155,\n    columnNumber: 5\n  }, this);\n};\n_s(Board, \"6vhGjjL2Xr1Cg00qY50Mqs9FA54=\");\n_c = Board;\nexport default Board;\nvar _c;\n$RefreshReg$(_c, \"Board\");","map":{"version":3,"names":["React","useState","useCallback","useRef","useEffect","Lane","Card","FlyingCardAnimation","jsxDEV","_jsxDEV","Board","_s","lanes","setLanes","id","title","cards","text","flyingAnimations","setFlyingAnimations","cardRefs","Map","laneRefs","current","clear","getCardById","cardId","lane","card","find","c","moveCard","currentLaneId","targetLaneId","prevLanes","newLanes","map","movedCard","sourceLaneIndex","findIndex","cardIndex","splice","targetLaneIndex","push","programmaticMoveCard","cardElement","get","targetLaneElement","console","warn","startRect","getBoundingClientRect","currentCardData","prev","Date","now","requestAnimationFrame","endCardElement","endRect","anim","filter","handleAnimationEnd","className","children","onClick","fileName","_jsxFileName","lineNumber","columnNumber","ref","el","set","index","isFlyingClone","some","laneId","style","visibility","onAnimationEnd","_c","$RefreshReg$"],"sources":["/Users/ralf/PyPrograms/KanbanFlow-Web/kanban-gui-test/src/components/Board.js"],"sourcesContent":["// src/components/Board.js\nimport React, { useState, useCallback, useRef, useEffect } from 'react'; // <--- Import useRef and useEffect\nimport Lane from './Lane';\nimport Card from './Card'; // Import Card to use its structure for flying clones\nimport FlyingCardAnimation from './FlyingCardAnimation'; // <--- Import new component\n\nconst Board = () => {\n  const [lanes, setLanes] = useState([\n    {\n      id: 'lane-1',\n      title: 'To Do',\n      cards: [\n        { id: 'card-1', text: 'Define project scope' },\n        { id: 'card-2', text: 'Research market trends' },\n      ],\n    },\n    {\n      id: 'lane-2',\n      title: 'In Progress',\n      cards: [\n        { id: 'card-3', text: 'Develop initial prototype' },\n      ],\n    },\n    {\n      id: 'lane-3',\n      title: 'Done',\n      cards: [\n        { id: 'card-4', text: 'Brainstorming session' },\n      ],\n    },\n  ]);\n\n  // NEW: State to manage cards currently in flying animation\n  const [flyingAnimations, setFlyingAnimations] = useState([]);\n\n  // NEW: Store refs for each card element for position calculation\n  // We use useRef for a mutable object that persists across renders\n  // and a Map inside it to store refs dynamically for each card ID.\n  const cardRefs = useRef(new Map());\n  const laneRefs = useRef(new Map()); // Also need lane refs for target position\n\n  // This effect updates the cardRefs Map when cards or lanes change\n  useEffect(() => {\n    // Clean up old refs\n    cardRefs.current.clear();\n    laneRefs.current.clear();\n  }, [lanes]); // Re-run if lanes state structure changes, ensuring refs are fresh\n\n  // Helper to get a card by its ID from current lanes state\n  const getCardById = useCallback((cardId) => {\n    for (const lane of lanes) {\n      const card = lane.cards.find(c => c.id === cardId);\n      if (card) return card;\n    }\n    return null;\n  }, [lanes]);\n\n  // Existing: Function to handle card moves via drag-and-drop\n  const moveCard = useCallback((cardId, currentLaneId, targetLaneId) => {\n    setLanes((prevLanes) => {\n      const newLanes = prevLanes.map((lane) => ({ ...lane, cards: [...lane.cards] }));\n\n      let movedCard = null;\n      const sourceLaneIndex = newLanes.findIndex((lane) => lane.id === currentLaneId);\n      if (sourceLaneIndex > -1) {\n        const cardIndex = newLanes[sourceLaneIndex].cards.findIndex((card) => card.id === cardId);\n        if (cardIndex > -1) {\n          movedCard = newLanes[sourceLaneIndex].cards.splice(cardIndex, 1)[0];\n        }\n      }\n\n      if (movedCard) {\n        const targetLaneIndex = newLanes.findIndex((lane) => lane.id === targetLaneId);\n        if (targetLaneIndex > -1) {\n          newLanes[targetLaneIndex].cards.push(movedCard);\n        }\n      }\n      return newLanes;\n    });\n  }, []);\n\n\n  // NEW: Programmatic move function with gliding animation\n  const programmaticMoveCard = useCallback((cardId, targetLaneId) => {\n    const cardElement = cardRefs.current.get(cardId);\n    const targetLaneElement = laneRefs.current.get(targetLaneId);\n\n    if (!cardElement || !targetLaneElement) {\n      console.warn(`Could not find element for card ${cardId} or lane ${targetLaneId}`);\n      return;\n    }\n\n    const startRect = cardElement.getBoundingClientRect();\n    const currentCardData = getCardById(cardId);\n\n    // Prepare to initiate the animation *before* moving the actual card in state\n    setFlyingAnimations(prev => [\n      ...prev,\n      {\n        id: `flying-${cardId}-${Date.now()}`, // Unique ID for the animation instance\n        card: currentCardData,\n        startRect: startRect,\n        // The endRect will be calculated after the actual card moves in the DOM\n      }\n    ]);\n\n    // Perform the actual card move in state\n    setLanes((prevLanes) => {\n      const newLanes = prevLanes.map((lane) => ({ ...lane, cards: [...lane.cards] }));\n      let movedCard = null;\n      const sourceLaneIndex = newLanes.findIndex((lane) => {\n          const cardIndex = lane.cards.findIndex((card) => card.id === cardId);\n          if (cardIndex > -1) {\n              movedCard = lane.cards.splice(cardIndex, 1)[0];\n              return true;\n          }\n          return false;\n      });\n\n      if (movedCard) {\n        const targetLaneIndex = newLanes.findIndex((lane) => lane.id === targetLaneId);\n        if (targetLaneIndex > -1) {\n          newLanes[targetLaneIndex].cards.push(movedCard);\n        }\n      }\n      return newLanes;\n    });\n\n    // Use a short timeout to allow React to render the card in its new position\n    // then calculate its endRect and trigger the animation.\n    requestAnimationFrame(() => { // Using rAF for next paint, often better than setTimeout(0)\n      const endCardElement = cardRefs.current.get(cardId);\n      if (endCardElement) {\n        const endRect = endCardElement.getBoundingClientRect();\n        // Update the flying animation entry with its endRect\n        setFlyingAnimations(prev => prev.map(anim =>\n          anim.card.id === cardId && !anim.endRect\n            ? { ...anim, endRect: endRect }\n            : anim\n        ));\n      } else {\n        // If the card is no longer in DOM (e.g. removed for some reason), clean up flying animation\n        setFlyingAnimations(prev => prev.filter(anim => anim.card.id !== cardId));\n      }\n    });\n\n  }, [getCardById]);\n\n  // NEW: Callback for when a flying animation ends\n  const handleAnimationEnd = useCallback((cardId) => {\n    setFlyingAnimations(prev => prev.filter(anim => anim.card.id !== cardId));\n  }, []);\n\n  return (\n    <div className=\"flex p-8 overflow-x-auto min-h-screen items-start bg-gray-50\">\n      {/* Demo button for automatic movement */}\n      <button\n        onClick={() => programmaticMoveCard('card-1', 'lane-2')} // Moves 'card-1' to 'lane-2'\n        className=\"fixed bottom-4 right-4 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded shadow-lg z-50\"\n      >\n        Auto Move Card 1 to 'In Progress' (Gliding)\n      </button>\n\n      {lanes.map((lane) => (\n        <div\n          key={lane.id}\n          ref={el => { if (el) laneRefs.current.set(lane.id, el); }} // Assign ref to lane\n          className=\"w-80 p-4 rounded-lg shadow-inner flex-shrink-0 mr-4 bg-gray-100\" // Note: removed isOver color for simplicity\n        >\n          <h2 className=\"text-xl font-semibold mb-4 text-gray-800 border-b border-gray-300 pb-2\">{lane.title}</h2>\n          {lane.cards.map((card, index) => {\n            // Check if this card is currently being animated as a flying clone\n            const isFlyingClone = flyingAnimations.some(anim => anim.card.id === card.id && anim.endRect);\n            return (\n              <Card\n                key={card.id}\n                id={card.id}\n                text={card.text}\n                laneId={lane.id}\n                index={index}\n                // Pass ref to the actual card so we can get its position\n                ref={el => { if (el) cardRefs.current.set(card.id, el); }}\n                // Hide the actual card while its clone is flying\n                style={{ visibility: isFlyingClone ? 'hidden' : 'visible' }}\n              />\n            );\n          })}\n        </div>\n      ))}\n\n      {/* Render flying animations */}\n      {flyingAnimations.map(anim => anim.startRect && anim.endRect && (\n        <FlyingCardAnimation\n          key={anim.id}\n          card={anim.card}\n          startRect={anim.startRect}\n          endRect={anim.endRect}\n          onAnimationEnd={handleAnimationEnd}\n        />\n      ))}\n    </div>\n  );\n};\n\nexport default Board;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}